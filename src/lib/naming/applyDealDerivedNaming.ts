/**
 * Apply derived naming to a deal after document classification.
 *
 * Reads all classified documents for the deal, picks the best anchor doc,
 * and updates the deal name if the current name is provisional/auto-generated.
 *
 * Guards:
 *   - name_locked = true  → never overwrite
 *   - naming_method = 'manual' → never overwrite
 *   - current name is NOT an auto-generated fallback → skip
 *   - confidence < 0.80  → skip (conservative)
 *
 * Emits canonical `deal.name.derived` ledger events via writeEvent.
 * Idempotent: same inputs produce the same name.
 */

import "server-only";

import { supabaseAdmin } from "@/lib/supabase/admin";
import { deriveDealName, type AnchorDocCandidate } from "./deriveDealName";
import { isAutoGeneratedDealName } from "@/lib/deals/isAutoGeneratedDealName";
import { writeEvent } from "@/lib/ledger/writeEvent";

const MIN_CONFIDENCE = 0.80;

export type ApplyDealDerivedNamingResult = {
  ok: boolean;
  dealName: string | null;
  method: "provisional" | "derived" | "manual" | null;
  changed: boolean;
  error?: string;
};

export async function applyDealDerivedNaming(opts: {
  dealId: string;
  bankId: string;
}): Promise<ApplyDealDerivedNamingResult> {
  const { dealId, bankId } = opts;
  const sb = supabaseAdmin();

  // 1. Read current deal state
  const { data: deal, error: dealErr } = await sb
    .from("deals")
    .select("id, display_name, name, naming_method, name_locked")
    .eq("id", dealId)
    .maybeSingle();

  if (dealErr || !deal) {
    await emitDealNameDerived(dealId, {
      previous_name: null,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: false, extraction: false, ocr: false },
      fallback_reason: "blocked_deal_access",
      locked: false,
    });
    return { ok: false, dealName: null, method: null, changed: false, error: dealErr?.message ?? "deal_not_found" };
  }

  const currentName = (deal as any).display_name ?? (deal as any).name ?? null;
  const locked = Boolean((deal as any).name_locked);

  // Guard: name_locked
  if (locked) {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: false, extraction: false, ocr: false },
      fallback_reason: "locked",
      locked: true,
    });
    return { ok: true, dealName: currentName, method: "manual", changed: false };
  }

  // Guard: naming_method = manual
  if ((deal as any).naming_method === "manual") {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: false, extraction: false, ocr: false },
      fallback_reason: "locked",
      locked: false,
    });
    return { ok: true, dealName: currentName, method: "manual", changed: false };
  }

  // Guard: one auto-upgrade max — if already derived, never auto-rename again
  if ((deal as any).naming_method === "derived") {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: true, extraction: false, ocr: false },
      fallback_reason: "already_derived",
      locked: false,
    });
    return { ok: true, dealName: currentName, method: "derived", changed: false };
  }

  // Guard: only auto-update if deal name is currently auto-generated / fallback
  if (!isAutoGeneratedDealName(currentName) && (deal as any).naming_method !== "fallback") {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: false, extraction: false, ocr: false },
      fallback_reason: "not_fallback_name",
      locked: false,
    });
    return { ok: true, dealName: currentName, method: "provisional", changed: false };
  }

  // 2. Get all classified documents for this deal (anchor candidates)
  const { data: docs, error: docsErr } = await sb
    .from("deal_documents")
    .select("document_type, doc_year, entity_name, ai_business_name, ai_borrower_name, match_confidence")
    .eq("deal_id", dealId)
    .not("document_type", "is", null);

  if (docsErr) {
    return { ok: false, dealName: null, method: null, changed: false, error: docsErr.message };
  }

  const hasClassification = Boolean(docs && docs.length > 0);

  if (!docs || docs.length === 0) {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: false, extraction: false, ocr: false },
      fallback_reason: "no_docs",
      locked: false,
    });
    return { ok: true, dealName: currentName, method: "provisional", changed: false };
  }

  // Filter by confidence threshold (spec: >= 0.80)
  const confidentDocs = docs.filter(
    (d: any) => typeof d.match_confidence === "number" && d.match_confidence >= MIN_CONFIDENCE,
  );

  if (confidentDocs.length === 0) {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: hasClassification, extraction: false, ocr: false },
      fallback_reason: "low_confidence",
      locked: false,
    });
    return { ok: true, dealName: currentName, method: "provisional", changed: false };
  }

  // Build anchor candidates: pick best entity name per doc
  const candidates: AnchorDocCandidate[] = confidentDocs.map((d: any) => ({
    documentType: d.document_type,
    docYear: d.doc_year,
    entityName: d.ai_business_name || d.ai_borrower_name || d.entity_name || null,
    confidence: d.match_confidence,
  }));

  // 3. Derive deal name
  const result = deriveDealName(candidates);

  if (!result.dealName) {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: null,
      changed: false,
      source: "fallback",
      confidence: null,
      inputs_present: { classification: hasClassification, extraction: false, ocr: false },
      fallback_reason: result.fallbackReason ?? "missing_extraction",
      locked: false,
    });
    return { ok: true, dealName: currentName, method: "provisional", changed: false };
  }

  // 4. Check if name changed (idempotency)
  if (currentName === result.dealName) {
    await emitDealNameDerived(dealId, {
      previous_name: currentName,
      derived_name: result.dealName,
      changed: false,
      source: "ocr_entity_extraction",
      confidence: candidates[0]?.confidence ?? null,
      inputs_present: { classification: true, extraction: true, ocr: true },
      locked: false,
    });
    return { ok: true, dealName: result.dealName, method: "derived", changed: false };
  }

  // 5. Update deal (only columns that exist in schema)
  const nowIso = new Date().toISOString();
  const { error: updateErr } = await sb
    .from("deals")
    .update({
      display_name: result.dealName,
      naming_method: "derived",
      naming_source: result.source,
      naming_fallback_reason: null,
      named_at: nowIso,
    } as any)
    .eq("id", dealId);

  if (updateErr) {
    return { ok: false, dealName: null, method: null, changed: false, error: updateErr.message };
  }

  // 6. Emit canonical ledger event
  await emitDealNameDerived(dealId, {
    previous_name: currentName,
    derived_name: result.dealName,
    changed: true,
    source: "ocr_entity_extraction",
    confidence: candidates[0]?.confidence ?? null,
    inputs_present: { classification: true, extraction: true, ocr: true },
    locked: false,
  });

  return {
    ok: true,
    dealName: result.dealName,
    method: "derived",
    changed: true,
  };
}

// ─── Canonical ledger helper ────────────────────────────────────────────────

type DealNameDerivedPayload = {
  previous_name: string | null;
  derived_name: string | null;
  changed: boolean;
  source: "ocr_entity_extraction" | "classification" | "fallback";
  confidence: number | null;
  inputs_present: {
    classification: boolean;
    extraction: boolean;
    ocr: boolean;
  };
  fallback_reason?: string;
  locked: boolean;
};

async function emitDealNameDerived(
  dealId: string,
  payload: DealNameDerivedPayload,
): Promise<void> {
  await writeEvent({
    dealId,
    kind: "deal.name.derived",
    scope: "naming",
    action: "derive_deal_name",
    output: payload,
    confidence: payload.confidence,
    meta: {
      changed: payload.changed,
      source: payload.source,
      locked: payload.locked,
      fallback_reason: payload.fallback_reason ?? null,
    },
  });
}
