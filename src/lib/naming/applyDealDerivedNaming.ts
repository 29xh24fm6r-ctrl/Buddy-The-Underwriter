/**
 * Apply derived naming to a deal after document classification.
 *
 * Reads all classified documents for the deal, picks the best anchor doc,
 * and updates the deal name if the current name is provisional/auto-generated.
 *
 * Respects manual naming: never overwrites a user-chosen name.
 * Idempotent: same inputs produce the same name.
 */

import "server-only";

import { supabaseAdmin } from "@/lib/supabase/admin";
import { deriveDealName, type AnchorDocCandidate } from "./deriveDealName";
import { isAutoGeneratedDealName } from "@/lib/deals/isAutoGeneratedDealName";
import { logLedgerEvent } from "@/lib/pipeline/logLedgerEvent";

export type ApplyDealDerivedNamingResult = {
  ok: boolean;
  dealName: string | null;
  method: "provisional" | "derived" | "manual" | null;
  changed: boolean;
  error?: string;
};

export async function applyDealDerivedNaming(opts: {
  dealId: string;
  bankId: string;
}): Promise<ApplyDealDerivedNamingResult> {
  const { dealId, bankId } = opts;
  const sb = supabaseAdmin();

  // 1. Read current deal state
  const { data: deal, error: dealErr } = await sb
    .from("deals")
    .select("id, display_name, name, naming_method")
    .eq("id", dealId)
    .maybeSingle();

  if (dealErr || !deal) {
    return { ok: false, dealName: null, method: null, changed: false, error: dealErr?.message ?? "deal_not_found" };
  }

  // Don't overwrite manual naming
  if ((deal as any).naming_method === "manual") {
    return {
      ok: true,
      dealName: (deal as any).display_name ?? (deal as any).name,
      method: "manual",
      changed: false,
    };
  }

  // Only auto-update if deal name is currently auto-generated / provisional
  const currentName = (deal as any).display_name ?? (deal as any).name ?? null;
  if (!isAutoGeneratedDealName(currentName) && (deal as any).naming_method === "derived") {
    // Already has a derived name that's not garbage — skip
    return { ok: true, dealName: currentName, method: "derived", changed: false };
  }

  // 2. Get all classified documents for this deal (anchor candidates)
  const { data: docs, error: docsErr } = await sb
    .from("deal_documents")
    .select("document_type, doc_year, entity_name, ai_business_name, ai_borrower_name, classification_confidence")
    .eq("deal_id", dealId)
    .not("document_type", "is", null);

  if (docsErr) {
    return { ok: false, dealName: null, method: null, changed: false, error: docsErr.message };
  }

  if (!docs || docs.length === 0) {
    // No classified docs yet — emit failure event
    await logLedgerEvent({
      dealId,
      bankId,
      eventKey: "deal.name.derive_failed",
      uiState: "done",
      uiMessage: "No classified documents to derive deal name from",
      meta: { fallback_reason: "no_classified_documents" },
    });

    return { ok: true, dealName: currentName, method: "provisional", changed: false };
  }

  // Build anchor candidates: pick best entity name per doc
  const candidates: AnchorDocCandidate[] = docs.map((d: any) => ({
    documentType: d.document_type,
    docYear: d.doc_year,
    entityName: d.ai_business_name || d.ai_borrower_name || d.entity_name || null,
    confidence: d.classification_confidence,
  }));

  // 3. Derive deal name
  const result = deriveDealName(candidates);

  if (!result.dealName) {
    await logLedgerEvent({
      dealId,
      bankId,
      eventKey: "deal.name.derive_failed",
      uiState: "done",
      uiMessage: "Could not derive deal name from classified documents",
      meta: {
        fallback_reason: result.fallbackReason,
        candidate_count: candidates.length,
      },
    });

    return { ok: true, dealName: currentName, method: "provisional", changed: false };
  }

  // 4. Check if name changed (idempotency)
  if (currentName === result.dealName) {
    return { ok: true, dealName: result.dealName, method: "derived", changed: false };
  }

  // 5. Update deal
  const nowIso = new Date().toISOString();
  const { error: updateErr } = await sb
    .from("deals")
    .update({
      display_name: result.dealName,
      naming_method: "derived",
      naming_source: result.source,
      naming_fallback_reason: null,
      named_at: nowIso,
      name_source: result.source,
      name_updated_at: nowIso,
    } as any)
    .eq("id", dealId);

  if (updateErr) {
    await logLedgerEvent({
      dealId,
      bankId,
      eventKey: "deal.name.derive_failed",
      uiState: "error",
      uiMessage: "Failed to update deal name",
      meta: {
        error: updateErr.message,
        attempted_name: result.dealName,
      },
    });

    return { ok: false, dealName: null, method: null, changed: false, error: updateErr.message };
  }

  // 6. Emit success event
  await logLedgerEvent({
    dealId,
    bankId,
    eventKey: "deal.name.derived_set",
    uiState: "done",
    uiMessage: `Deal name set to "${result.dealName}"`,
    meta: {
      previous_name: currentName,
      new_name: result.dealName,
      source: result.source,
      anchor_doc_type: result.anchorDocType,
    },
  });

  return {
    ok: true,
    dealName: result.dealName,
    method: "derived",
    changed: true,
  };
}
