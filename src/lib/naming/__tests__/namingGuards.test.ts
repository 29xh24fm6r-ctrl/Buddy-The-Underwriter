/**
 * Unit tests for naming derivation guard logic.
 *
 * Tests the "one auto-upgrade max" contract:
 *   - derived-once: naming_method='derived' blocks re-derivation
 *   - locked: name_locked=true blocks all auto-rename
 *   - fallback detection: isAutoGeneratedDealName correctly identifies fallback names
 *
 * Run: npx tsx src/lib/naming/__tests__/namingGuards.test.ts
 */

import { isAutoGeneratedDealName } from "@/lib/deals/isAutoGeneratedDealName";
import assert from "node:assert/strict";

function test(name: string, fn: () => void) {
  try {
    fn();
    console.log(`  ✓ ${name}`);
  } catch (e: any) {
    console.error(`  ✗ ${name}`);
    console.error(`    ${e.message}`);
    process.exitCode = 1;
  }
}

// ─── Guard: isAutoGeneratedDealName ─────────────────────────────────────────

console.log("isAutoGeneratedDealName");

test("null → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName(null), true);
});

test("undefined → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName(undefined), true);
});

test("empty string → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName(""), true);
});

test("whitespace only → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("   "), true);
});

test("'Deal - 1/28/2026' → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("Deal - 1/28/2026"), true);
});

test("'Deal - 12/31/25' → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("Deal - 12/31/25"), true);
});

test("'Pending Autofill' → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("Pending Autofill"), true);
});

test("'Untitled deal' → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("Untitled deal"), true);
});

test("'New Deal' → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("New Deal"), true);
});

test("UUID in name → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("Deal a1b2c3d4-e5f6-7890-abcd-ef1234567890"), true);
});

test("hex prefix → auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("Deal 1433a5c7e9"), true);
});

test("'ABC Corp — BTR 2023' → NOT auto-generated (derived name)", () => {
  assert.equal(isAutoGeneratedDealName("ABC Corp — BTR 2023"), false);
});

test("'John Doe' → NOT auto-generated (user name)", () => {
  assert.equal(isAutoGeneratedDealName("John Doe"), false);
});

test("'My Custom Deal Name' → NOT auto-generated", () => {
  assert.equal(isAutoGeneratedDealName("My Custom Deal Name"), false);
});

// ─── Guard: one-auto-upgrade-max contract ───────────────────────────────────

console.log("\none-auto-upgrade-max contract");

/**
 * Simulates the guard decision logic from applyDealDerivedNaming.
 * This mirrors the actual code's guard chain without needing DB access.
 */
function shouldAutoDeriveDeal(opts: {
  nameLocked: boolean;
  namingMethod: string | null;
  currentName: string | null;
}): { allowed: boolean; reason: string } {
  const { nameLocked, namingMethod, currentName } = opts;

  if (nameLocked) return { allowed: false, reason: "locked" };
  if (namingMethod === "manual") return { allowed: false, reason: "locked" };
  if (namingMethod === "derived") return { allowed: false, reason: "already_derived" };
  if (!isAutoGeneratedDealName(currentName) && namingMethod !== "fallback") {
    return { allowed: false, reason: "not_fallback_name" };
  }

  return { allowed: true, reason: "eligible" };
}

test("fallback name + naming_method=null → allowed", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: false, namingMethod: null, currentName: "Deal - 1/28/2026" });
  assert.equal(r.allowed, true);
});

test("fallback name + naming_method='fallback' → allowed", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: false, namingMethod: "fallback", currentName: "Deal - 1/28/2026" });
  assert.equal(r.allowed, true);
});

test("naming_method='derived' → blocked (already_derived)", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: false, namingMethod: "derived", currentName: "ABC Corp — BTR 2023" });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "already_derived");
});

test("naming_method='derived' + auto-generated name → still blocked (one upgrade max)", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: false, namingMethod: "derived", currentName: "Deal - 1/28/2026" });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "already_derived");
});

test("name_locked=true → blocked (locked)", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: true, namingMethod: "manual", currentName: "My Renamed Deal" });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "locked");
});

test("naming_method='manual' + not locked → blocked (locked via method)", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: false, namingMethod: "manual", currentName: "Custom Name" });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "locked");
});

test("non-fallback name + non-fallback method → blocked", () => {
  const r = shouldAutoDeriveDeal({ nameLocked: false, namingMethod: "provisional", currentName: "Real Name" });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "not_fallback_name");
});

// ─── Guard: one-auto-upgrade-max for documents ─────────────────────────────

console.log("\ndocument one-auto-upgrade-max contract");

function shouldAutoDeriveDocument(opts: {
  nameLocked: boolean;
  namingMethod: string | null;
  confidence: number | null;
}): { allowed: boolean; reason: string } {
  const { nameLocked, namingMethod, confidence } = opts;

  if (nameLocked) return { allowed: false, reason: "locked" };
  if (namingMethod === "manual") return { allowed: false, reason: "locked" };
  if (namingMethod === "derived") return { allowed: false, reason: "already_derived" };
  if (typeof confidence === "number" && confidence < 0.80) {
    return { allowed: false, reason: "low_confidence" };
  }

  return { allowed: true, reason: "eligible" };
}

test("filename method + high confidence → allowed", () => {
  const r = shouldAutoDeriveDocument({ nameLocked: false, namingMethod: "filename", confidence: 0.92 });
  assert.equal(r.allowed, true);
});

test("naming_method='derived' → blocked (already_derived)", () => {
  const r = shouldAutoDeriveDocument({ nameLocked: false, namingMethod: "derived", confidence: 0.95 });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "already_derived");
});

test("name_locked=true → blocked", () => {
  const r = shouldAutoDeriveDocument({ nameLocked: true, namingMethod: "manual", confidence: 0.95 });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "locked");
});

test("low confidence → blocked", () => {
  const r = shouldAutoDeriveDocument({ nameLocked: false, namingMethod: "filename", confidence: 0.65 });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "low_confidence");
});

test("null confidence → allowed (no threshold to fail)", () => {
  const r = shouldAutoDeriveDocument({ nameLocked: false, namingMethod: "filename", confidence: null });
  assert.equal(r.allowed, true);
});

test("naming_method='manual' without lock → blocked", () => {
  const r = shouldAutoDeriveDocument({ nameLocked: false, namingMethod: "manual", confidence: 0.99 });
  assert.equal(r.allowed, false);
  assert.equal(r.reason, "locked");
});

console.log("\nAll tests passed!");
